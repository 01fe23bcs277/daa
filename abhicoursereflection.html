<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Reflections</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            line-height: 1.6;
            background-color: #f4f4f9;
        }
        .container {
            width: 80%;
            margin: 0 auto;
            overflow: hidden;
        }
        .section {
            background: #fff;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .section h2 {
            margin-top: 0;
            color: #333;
        }
        .description {
            margin: 10px 0 0 20px;
        }
    </style>
</head>
<body>
    <header>
        <h1 style="text-align: center; padding: 20px; background-color: #333; color: #fff; margin: 0;">Course Reflections</h1>
    </header>
    <div class="container">
        <!-- Portfolio Sections -->
        <div class="section">
            <h2>What are the kinds of problems we see in the nature? (iteration, recursion, backtracking).</h2>
            <div class="description">
              <h3>Iteration in Nature</h3>  
  - Repetitive cycles like seasons, tides, and the water cycle.  
  - Daily and yearly natural processes that repeat continuously.

<h3>Recursion in Nature</h3>  
  - Fractal patterns like tree branches and snowflakes.  
  - Self-similar structures, where each part mirrors the whole.

<h3>Backtracking in Nature</h3>  
  - Animal migration patterns, where they return if obstacles are encountered.  
  - Adaptive paths and decisions in response to challenges.</div>
        </div>

        <div class="section">
            <h2>What is space and time efficiency? Why are they important? Explain the different class of problems and orders of growth.</h2>
            <div class="description">  <h1>Space and Time Efficiency</h1>

    <h2>Space Efficiency</h2>
    <p class="definition">Space Efficiency:</p>
    <ul>
        <li>Refers to the amount of memory or storage required by an algorithm to solve a problem.</li>
        <li>Focuses on minimizing memory usage.</li>
    </ul>
    <p><strong>Why Important:</strong> Limited memory resources make space efficiency crucial, especially in embedded systems, mobile devices, or large-scale data processing tasks.</p>

    <h2>Time Efficiency</h2>
    <p class="definition">Time Efficiency:</p>
    <ul>
        <li>Refers to the amount of time an algorithm takes to run, typically measured as a function of input size.</li>
    </ul>
    <p><strong>Why Important:</strong> Faster algorithms ensure that tasks can be completed in a reasonable time, which is critical in applications that require real-time processing or large data sets.</p>

    <h2>Classes of Problems and Orders of Growth</h2>
    <h3>1. Constant Time (O(1))</h3>
    <ul>
        <li><strong>Definition:</strong> The execution time or space requirement does not depend on the size of the input.</li>
        <li><strong>Example:</strong> Accessing an element in an array by index.</li>
    </ul>

    <h3>2. Logarithmic Time (O(log n))</h3>
    <ul>
        <li><strong>Definition:</strong> The execution time grows logarithmically as the input size increases.</li>
        <li><strong>Example:</strong> Binary search in a sorted array.</li>
    </ul>

    <h3>3. Linear Time (O(n))</h3>
    <ul>
        <li><strong>Definition:</strong> The execution time grows linearly with the input size.</li>
        <li><strong>Example:</strong> Iterating through all elements of an array.</li>
    </ul>

    <h3>4. Linearithmic Time (O(n log n))</h3>
    <ul>
        <li><strong>Definition:</strong> The time grows as a product of n and log n, which is more efficient than quadratic time but less than linear time.</li>
        <li><strong>Example:</strong> Merge sort and quicksort.</li>
    </ul>

    <h3>5. Quadratic Time (O(n²))</h3>
    <ul>
        <li><strong>Definition:</strong> The execution time grows quadratically as the input size increases.</li>
        <li><strong>Example:</strong> Bubble sort, selection sort.</li>
    </ul>

    <h3>6. Cubic Time (O(n³))</h3>
    <ul>
        <li><strong>Definition:</strong> The time grows cubically with the input size.</li>
        <li><strong>Example:</strong> Some dynamic programming algorithms.</li>
    </ul>

    <h3>7. Exponential Time (O(2^n))</h3>
    <ul>
        <li><strong>Definition:</strong> The time grows exponentially as the input size increases, making these algorithms inefficient for large inputs.</li>
        <li><strong>Example:</strong> Solving the traveling salesman problem using brute force.</li>
    </ul>

    <h3>8. Factorial Time (O(n!))</h3>
    <ul>
        <li><strong>Definition:</strong> The execution time grows factorially, leading to very slow algorithms as n increases.</li>
        <li><strong>Example:</strong> Brute force solution to the traveling salesman problem.</li>
    </ul>

    <h2>Why Are They Important?</h2>
    <ul>
        <li><strong>Space Efficiency:</strong> Reduces hardware requirements and ensures the program runs even with limited memory.</li>
        <li><strong>Time Efficiency:</strong> Ensures that the program can handle larger inputs efficiently, preventing delays and bottlenecks in critical systems.</li>
    </ul></div>
 </div>

        <div class="section">
            <h2>Take away from different design principles from chapter 2 (can use the notes provided).</h2>
            <div class="description"> <h1>Design Principles - Chapter 2 Takeaways</h1>

    </div>
        </div>

        <div class="section">
            <h2>The hierarchical data and how different tree data structures solve and optimize over the problem scenarios (tree, bst, avl, 2-3, red-black, heap, trie).</h2>
            <div class="description"> <h1>Hierarchical Data and Tree Data Structures</h1>
    <h3>How Different Tree Structures Solve and Optimize Problem Scenarios</h3>

    <h2>1. Tree</h2>
    <ul>
        <li>General structure with nodes and edges, forming a hierarchy.</li>
        <li>Use Case: Organizing hierarchical data like file systems.</li>
    </ul>

    <h2>2. Binary Search Tree (BST)</h2>
    <ul>
        <li>Binary tree where left child < parent < right child.</li>
        <li>Use Case: Sorted data and fast lookups.</li>
    </ul>

    <h2>3. AVL Tree</h2>
    <ul>
        <li>Self-balancing BST ensuring height balance for O(log n) operations.</li>
        <li>Use Case: Frequent updates and fast lookups.</li>
    </ul>

    <h2>4. 2-3 Tree</h2>
    <ul>
        <li>Balanced tree with nodes having 2 or 3 children and 1 or 2 keys.</li>
        <li>Use Case: Disk-based storage systems requiring frequent balancing.</li>
    </ul>

    <h2>5. Red-Black Tree</h2>
    <ul>
        <li>Self-balancing BST with nodes colored red or black for balancing.</li>
        <li>Use Case: Used in Java's TreeMap, C++'s STL map.</li>
    </ul>

    <h2>6. Heap (Binary Heap)</h2>
    <ul>
        <li>Complete binary tree, with parent greater (max heap) or smaller (min heap) than children.</li>
        <li>Use Case: Priority queues, heap sort, dynamic order statistics.</li>
    </ul>

    <h2>7. Trie (Prefix Tree)</h2>
    <ul>
        <li>Tree structure used to store strings, where each node represents a character.</li>
        <li>Use Case: Autocomplete, dictionary implementations, IP routing.</li>
    </ul></div>
        </div>

        <div class="section">
            <h2>The need of array query algorithms and their implications. Their applications and principles need to be discussed.</h2>
            <div class="description"> <h1>The Need for Array Query Algorithms</h1>
    <h3>Implications, Applications, and Principles</h3>

    <h2>1. Need for Efficient Querying</h2>
    <ul>
        <li>Arrays are fundamental data structures for storing and accessing data.</li>
        <li>Efficient querying in arrays is necessary for applications involving large datasets, real-time systems, and database management.</li>
    </ul>

    <h2>2. Implications of Query Algorithms</h2>
    <ul>
        <li>Improved query algorithms ensure faster data retrieval, minimizing latency.</li>
        <li>Efficiency is critical for performance, especially in large-scale applications or systems requiring high-speed access.</li>
    </ul>

    <h2>3. Applications of Array Query Algorithms</h2>
    <ul>
        <li><strong>Database Management Systems:</strong> Fast access to data stored in arrays, especially in relational databases.</li>
        <li><strong>Real-time Systems:</strong> Querying sensors, logs, or streams in real-time where speed is crucial.</li>
        <li><strong>Search Engines:</strong> Array-based structures like inverted indexes are used to optimize searching across large datasets.</li>
        <li><strong>Machine Learning:</strong> Efficient querying in arrays for data preprocessing and feature extraction.</li>
    </ul>

    <h2>4. Principles of Array Query Algorithms</h2>
    <ul>
        <li><strong>Time Complexity:</strong> Query algorithms should minimize time complexity (e.g., O(log n), O(1)) to handle large-scale data efficiently.</li>
        <li><strong>Space Complexity:</strong> Algorithms should optimize space usage to avoid memory overload in systems with limited resources.</li>
        <li><strong>Preprocessing:</strong> Some array query algorithms benefit from preprocessing (e.g., prefix sum, segment tree) to improve query efficiency.</li>
        <li><strong>Balance Between Query and Update:</strong> Algorithms should provide an optimal balance when both querying and updating data are frequent operations (e.g., in dynamic arrays).</li>
    </ul></div>
        </div>

        <div class="section">
            <h2>Differentiate between tree and graphs and their traversals. The applications of each.</h2>
            <div class="description"> <h1>Difference Between Tree and Graph and Their Traversals</h1>
    <h3>Applications and Traversal Methods</h3>

    <h2>1. Tree vs Graph</h2>
    <ul>
        <li><strong>Tree:</strong>
            <ul>
                <li>A tree is a hierarchical data structure consisting of nodes connected by edges. It has a single root node and each child node has only one parent.</li>
                <li>It is a type of graph with no cycles and is acyclic (directed or undirected).</li>
                <li>Example: Binary trees, AVL trees, and decision trees.</li>
            </ul>
        </li>
        <li><strong>Graph:</strong>
            <ul>
                <li>A graph is a collection of nodes (vertices) connected by edges. It can have cycles and multiple paths between nodes.</li>
                <li>Graphs can be directed (edges have direction) or undirected (edges are bidirectional).</li>
                <li>Example: Social networks, transportation systems, and computer networks.</li>
            </ul>
        </li>
    </ul>

    <h2>2. Tree Traversals</h2>
    <ul>
        <li><strong>In-order Traversal (Left, Root, Right):</strong> Used in binary trees to get nodes in a non-decreasing order.</li>
        <li><strong>Pre-order Traversal (Root, Left, Right):</strong> Useful for copying trees or evaluating expressions.</li>
        <li><strong>Post-order Traversal (Left, Right, Root):</strong> Used in scenarios like deleting a tree or evaluating postfix expressions.</li>
    </ul>

    <h2>3. Graph Traversals</h2>
    <ul>
        <li><strong>Depth-First Search (DFS):</strong> Explores as far as possible along each branch before backtracking. Implemented using recursion or a stack.</li>
        <li><strong>Breadth-First Search (BFS):</strong> Explores all the neighbors at the present depth before moving on to nodes at the next depth level. Implemented using a queue.</li>
    </ul>

    <h2>4. Applications of Tree</h2>
    <ul>
        <li><strong>Binary Trees:</strong> Used in expression evaluation, binary search trees for efficient searching and sorting.</li>
        <li><strong>AVL Trees:</strong> Used in databases and memory management for balanced search operations.</li>
        <li><strong>Decision Trees:</strong> Applied in machine learning for classification and regression tasks.</li>
    </ul>

    <h2>5. Applications of Graph</h2>
    <ul>
        <li><strong>Social Networks:</strong> Used to model relationships between users (nodes) and connections (edges).</li>
        <li><strong>Computer Networks:</strong> Graphs model the network topology, with nodes representing devices and edges representing connections.</li>
        <li><strong>Pathfinding Algorithms:</strong> Used in GPS systems and games to find the shortest path (e.g., Dijkstra's algorithm).</li>
    </ul></div>
        </div>

        <div class="section">
            <h2>Deliberate on sorting and searching algorithms, the technique behind each and they connect to real world</h2>
            <div class="description">  <h1>Sorting and Searching Algorithms</h1>
    <h3>Techniques and Real-World Applications</h3>

    <h2>1. Sorting Algorithms</h2>
    <ul>
        <li><strong>Bubble Sort:</strong>
            <ul>
                <li>Technique: Compares adjacent elements and swaps them if they are in the wrong order. Repeats until no swaps are needed.</li>
                <li>Real-World: Used in simple sorting tasks or when minimal code complexity is required, though inefficient for large datasets.</li>
            </ul>
        </li>
        <li><strong>Merge Sort:</strong>
            <ul>
                <li>Technique: Divides the dataset into smaller sublists, sorts them, and then merges them back together in a sorted order.</li>
                <li>Real-World: Used in databases and large-scale data processing where stable and efficient sorting is required.</li>
            </ul>
        </li>
        <li><strong>Quick Sort:</strong>
            <ul>
                <li>Technique: Selects a pivot element and partitions the data into two subarrays, then recursively sorts the subarrays.</li>
                <li>Real-World: Widely used in software like databases, and web technologies due to its efficiency on average.</li>
            </ul>
        </li>
        <li><strong>Heap Sort:</strong>
            <ul>
                <li>Technique: Builds a binary heap from the input data and extracts the maximum element, placing it into a sorted array.</li>
                <li>Real-World: Used in memory-constrained environments, like operating systems or real-time applications.</li>
            </ul>
        </li>
        <li><strong>Insertion Sort:</strong>
            <ul>
                <li>Technique: Builds the sorted array one element at a time by repeatedly picking the next element and inserting it into the correct position.</li>
                <li>Real-World: Useful in scenarios where data is already nearly sorted or when sorting small datasets.</li>
            </ul>
        </li>
    </ul>

    <h2>2. Searching Algorithms</h2>
    <ul>
        <li><strong>Linear Search:</strong>
            <ul>
                <li>Technique: Checks each element of the list sequentially until the desired element is found.</li>
                <li>Real-World: Used when datasets are small, or no prior sorting is available (e.g., searching through a simple list of items).</li>
            </ul>
        </li>
        <li><strong>Binary Search:</strong>
            <ul>
                <li>Technique: Requires a sorted array. It divides the dataset into halves, repeatedly narrowing down the search range based on comparisons with the middle element.</li>
                <li>Real-World: Used in searching operations within databases, dictionaries, or large-scale data storage where quick lookups are essential.</li>
            </ul>
        </li>
        <li><strong>Hashing:</strong>
            <ul>
                <li>Technique: Uses a hash function to map data to a fixed-size table (hash table) for quick access.</li>
                <li>Real-World: Key to efficient search in systems like databases, caches, and cryptography (e.g., password storage or lookup operations in large systems).</li>
            </ul>
        </li>
        <li><strong>Depth-First Search (DFS):</strong>
            <ul>
                <li>Technique: Explores all possible paths from a node in a graph, going deep into each branch before backtracking.</li>
                <li>Real-World: Used in search engines for crawling websites, and solving problems like puzzles, games, or in AI pathfinding algorithms.</li>
            </ul>
        </li>
        <li><strong>Breadth-First Search (BFS):</strong>
            <ul>
                <li>Technique: Explores all the neighboring nodes at the present depth level before moving on to nodes at the next level.</li>
                <li>Real-World: Applied in social networks for finding connections between users, and in networking to find the shortest path between devices.</li>
            </ul>
        </li>
    </ul>

    <h2>3. Applications of Sorting and Searching Algorithms</h2>
    <ul>
        <li><strong>Sorting:</strong>
            <ul>
                <li>Used in databases, file systems, and applications where data needs to be arranged in a specific order (e.g., customer records, e-commerce product listings).</li>
                <li>Important in algorithms for machine learning, analytics, and data visualization, ensuring accurate and fast processing of large datasets.</li>
            </ul>
        </li>
        <li><strong>Searching:</strong>
            <ul>
                <li>Used in applications like search engines (binary search for indexing), data analytics (finding specific data points), and real-time systems (quick lookups).</li>
                <li>Critical for systems like databases, cache systems, and security applications (password search, for example) where fast and efficient retrieval is required.</li>
            </ul>
        </li>
    </ul></div>
        </div>

        <div class="section">
            <h2>Discuss the importance of graph algorithms with respect to spanning trees and shortest paths.</h2>
            <div class="description"> <h1>Importance of Graph Algorithms: Spanning Trees and Shortest Paths</h1>
    <h3>Applications and Real-World Relevance</h3>

    <h2>1. Graph Algorithms: An Overview</h2>
    <ul>
        <li>Graph algorithms are essential for solving problems related to connectivity, pathfinding, and optimization within graph structures.</li>
        <li>Graphs are used to model various real-world scenarios like networks, maps, social relationships, and routing systems.</li>
    </ul>

    <h2>2. Spanning Trees</h2>
    <ul>
        <li><strong>Definition:</strong> A spanning tree of a graph is a subgraph that includes all the vertices of the graph, connected with the minimum number of edges, without forming any cycle.</li>
        <li><strong>Importance:</strong> 
            <ul>
                <li>Used to ensure efficient connectivity in networks, like telephone, computer, or electrical networks.</li>
                <li>Optimizes cost by minimizing the number of connections while maintaining full connectivity.</li>
            </ul>
        </li>
        <li><strong>Applications:</strong>
            <ul>
                <li><strong>Network Design:</strong> Spanning trees are used in designing least-cost networks such as Internet backbones or communication networks.</li>
                <li><strong>Minimum Spanning Tree (MST):</strong> Algorithms like Kruskal's or Prim's are used to find the MST in problems where the goal is to minimize the total weight (e.g., in designing a road network connecting cities with minimum cost).</li>
            </ul>
        </li>
    </ul>

    <h2>3. Shortest Paths</h2>
    <ul>
        <li><strong>Definition:</strong> The shortest path problem involves finding the path between two nodes in a graph such that the sum of the weights of the edges is minimized.</li>
        <li><strong>Importance:</strong>
            <ul>
                <li>Critical for optimizing routing in transportation systems, including GPS and map services.</li>
                <li>Used in communication networks to determine the fastest data transmission paths, thereby reducing latency and improving efficiency.</li>
            </ul>
        </li>
        <li><strong>Applications:</strong>
            <ul>
                <li><strong>GPS Navigation:</strong> Dijkstra's algorithm is widely used in navigation systems to find the shortest path between two locations on a map.</li>
                <li><strong>Telecommunications:</strong> Shortest path algorithms are used to route data in networks, optimizing bandwidth usage and reducing delays.</li>
                <li><strong>Airline and Train Systems:</strong> Used to find the shortest travel routes between stations or airports to minimize travel time.</li>
            </ul>
        </li>
    </ul>

    <h2>4. Graph Algorithms: Key Takeaways</h2>
    <ul>
        <li><strong>Spanning Trees:</strong> Provide a foundation for optimizing network structures by minimizing the cost of connections while maintaining connectivity.</li>
        <li><strong>Shortest Path Algorithms:</strong> Play a vital role in real-time navigation, data routing, and optimizing paths for various transportation systems.</li>
        <li>Graph algorithms like those for spanning trees and shortest paths are central to a wide range of practical applications across industries, improving efficiency, reducing costs, and enhancing user experiences.</li>
    </ul>.</div>
        </div>

        <div class="section">
            <h2>Discuss about the different studied algorithm design techniques.</h2>
            <div class="description"> <h1>Graph Algorithm Design Techniques</h1>
    <h3>Dijkstra's, Floyd's, Bellman-Ford, Kruskal's, Prim's, and Warshall Algorithms</h3>

    <h2>1. Dijkstra's Algorithm</h2>
    <ul>
        <li><strong>Purpose:</strong> Finds the shortest path between a source node and all other nodes in a weighted graph with non-negative weights.</li>
        <li><strong>Approach:</strong> Greedy algorithm. It iteratively selects the node with the smallest known distance and updates its neighbors.</li>
        <li><strong>Complexity:</strong> O(V^2) with a simple implementation, or O(E + V log V) with a priority queue.</li>
        <li><strong>Applications:</strong> Widely used in GPS navigation, networking, and routing protocols.</li>
    </ul>

    <h2>2. Floyd-Warshall Algorithm</h2>
    <ul>
        <li><strong>Purpose:</strong> Computes the shortest paths between all pairs of nodes in a graph, even with negative weights.</li>
        <li><strong>Approach:</strong> Dynamic programming. It incrementally updates the shortest path information for all node pairs.</li>
        <li><strong>Complexity:</strong> O(V^3), where V is the number of vertices in the graph.</li>
        <li><strong>Applications:</strong> Used in finding all-pairs shortest paths, especially in dense graphs like road networks or social network analysis.</li>
    </ul>

    <h2>3. Bellman-Ford Algorithm</h2>
    <ul>
        <li><strong>Purpose:</strong> Finds the shortest path from a single source to all other nodes, even with negative weight edges.</li>
        <li><strong>Approach:</strong> Dynamic programming. It relaxes all edges repeatedly, ensuring the shortest path is found even with negative weights.</li>
        <li><strong>Complexity:</strong> O(VE), where V is the number of vertices and E is the number of edges.</li>
        <li><strong>Applications:</strong> Used in detecting negative weight cycles, and in situations where Dijkstra’s algorithm cannot be applied due to negative weights.</li>
    </ul>

    <h2>4. Kruskal's Algorithm</h2>
    <ul>
        <li><strong>Purpose:</strong> Finds the minimum spanning tree (MST) of a graph.</li>
        <li><strong>Approach:</strong> Greedy algorithm. It sorts all edges by weight and adds edges to the tree as long as they don't form a cycle.</li>
        <li><strong>Complexity:</strong> O(E log E), where E is the number of edges, due to edge sorting.</li>
        <li><strong>Applications:</strong> Used in network design, such as in the design of computer networks and road networks.</li>
    </ul>

    <h2>5. Prim's Algorithm</h2>
    <ul>
        <li><strong>Purpose:</strong> Finds the minimum spanning tree (MST) of a graph.</li>
        <li><strong>Approach:</strong> Greedy algorithm. It starts with an arbitrary node and adds the closest node to the MST until all nodes are included.</li>
        <li><strong>Complexity:</strong> O(V^2) with a simple implementation, or O(E + V log V) with a priority queue.</li>
        <li><strong>Applications:</strong> Used in network design, such as for electrical grids, communication networks, and transportation systems.</li>
    </ul>

    <h2>6. Warshall's Algorithm</h2>
    <ul>
        <li><strong>Purpose:</strong> Computes the transitive closure of a graph, which helps in finding the reachability between nodes.</li>
        <li><strong>Approach:</strong> Dynamic programming. It iterates over all pairs of nodes and determines whether a path exists between them through an intermediate node.</li>
        <li><strong>Complexity:</strong> O(V^3), where V is the number of vertices in the graph.</li>
        <li><strong>Applications:</strong> Used in problems involving reachability in graphs, such as in determining if there is a route between two locations in transportation networks.</li>
    </ul>

    <h2>7. Summary of Techniques</h2>
    <ul>
        <li><strong>Dijkstra's:</strong> Best for finding the shortest path in a graph with non-negative weights.</li>
        <li><strong>Floyd-Warshall:</strong> Efficient for finding shortest paths between all pairs of nodes, especially in dense graphs.</li>
        <li><strong>Bellman-Ford:</strong> Works well with negative weights and can detect negative weight cycles.</li>
        <li><strong>Kruskal's & Prim's:</strong> Both find minimum spanning trees but use different approaches (edge-centric vs. node-centric).</li>
        <li><strong>Warshall's:</strong> Used for transitive closure and reachability in graphs.</li>
    </ul></div>
        </div>
    </div>
</body>
</html>
